# 电商秒杀系统Redis核心功能详细说明

本项目基于Redis实现了高并发下的电商秒杀、库存管理、分布式锁、缓存、购物车等功能。以下将每个功能的实现原理和流程详细讲解，适合初学者理解。

---

## 1. 商品库存的Redis预热与原子扣减（秒杀核心）

### 1.1 库存预热
- **目的**：系统启动时，把MySQL数据库里的商品库存数据提前加载到Redis，提升后续查询和扣减的速度。
- **实现流程**：
  1. 启动时，遍历所有商品。
  2. 以`product:stock:<商品ID>`为key，把每个商品的库存数量写入Redis。
  3. 这样后续秒杀请求直接查Redis即可，极大减轻数据库压力。

### 1.2 原子扣减库存
- **目的**：防止超卖，保证高并发下库存扣减的安全性。
- **实现流程**：
  1. 秒杀请求到来时，先在Redis用Lua脚本判断库存是否充足。
  2. 如果充足，Lua脚本会原子性地把库存减去购买数量。
  3. 如果库存不足或商品不存在，直接返回失败。
  4. 这种方式保证了并发下不会出现超卖。

### 1.3 库存回滚
- **场景**：下单失败时，需要把扣减的库存加回去。
- **实现**：同样用Lua脚本原子性地增加Redis中的库存。

---

## 2. 商品详情缓存与防止缓存穿透

### 2.1 商品详情缓存
- **目的**：减少数据库压力，提升商品详情查询速度。
- **实现流程**：
  1. 查询商品详情时，先查Redis缓存（key为`product:detail:<商品ID>`）。
  2. 如果缓存命中，直接返回。
  3. 如果缓存未命中，再查数据库，并把查到的结果写入Redis，设置1小时过期。

### 2.2 防止缓存穿透
- **问题**：有人恶意请求数据库中不存在的商品，可能导致数据库压力大。
- **解决**：
  1. 如果数据库查不到商品，也会在Redis里缓存一个"空值"标记（key为`product:null:<商品ID>`，值为null，5分钟过期）。
  2. 下次再查到这个空值，直接返回不存在，避免穿透数据库。

---

## 3. 分布式锁（Redis分布式锁）

### 3.1 获取分布式锁
- **目的**：保证同一资源（如同一商品）在同一时刻只能被一个线程操作，防止并发冲突。
- **实现流程**：
  1. 用`SETNX`命令（setIfAbsent）尝试在Redis中写入一个锁（key为锁名，value为唯一标识，带过期时间）。
  2. 如果写入成功，表示获得锁。
  3. 如果失败，说明其他线程已持有锁。

### 3.2 释放分布式锁
- **问题**：只有持有锁的线程才能释放锁，不能误删别人的锁。
- **实现**：
  1. 用Lua脚本判断锁的value是否等于自己持有的唯一标识。
  2. 如果相等才删除锁，否则不操作。

### 3.3 锁续期（看门狗机制）
- **问题**：业务执行时间过长，锁可能过期被其他线程抢走。
- **解决**：
  1. 获得锁后，启动定时任务定期为锁续期（重置过期时间）。
  2. 续期操作同样用Lua脚本，只有锁还属于自己时才续期。
  3. 业务完成后释放锁，同时取消续期任务。

---

## 4. 购物车功能（基于Redis的Hash结构）

### 4.1 购物车数据存储
- **方式**：每个用户的购物车在Redis中用Hash结构存储，key为`user:<userId>:cart`，field为商品SKU，value为数量。

### 4.2 添加/更新商品
- **实现**：用`HINCRBY`命令原子性地增加或减少某个商品的数量。

### 4.3 移除商品/清空购物车
- **实现**：用`HDEL`命令删除某个商品，用`DEL`命令清空整个购物车。

### 4.4 查询购物车
- **实现**：用`HGETALL`命令获取所有商品及数量。

---

## 5. Redis配置与序列化

- **自定义RedisTemplate**：配置了key、value、hashKey、hashValue的序列化方式，支持对象的JSON序列化，保证数据可读性和兼容性。
- **连接池优化**：通过配置文件调整了Redis连接池参数，提升高并发下的连接性能。

---

## 6. 异步订单处理 (消息队列)

为了应对高并发下的写请求压力，系统采用消息队列（RabbitMQ）对下单流程进行异步化改造。

- **目的**：将耗时的数据库写操作从主请求流程中剥离，极大缩短接口响应时间，提升系统吞吐量和用户体验。
- **实现流程**：
  1.  **快速响应**：秒杀请求到达后，在Redis中原子扣减库存成功后，系统不再等待数据库写入，而是立即向消息队列发送一条包含订单信息的消息。
  2.  **立即返回**：消息发送成功后，立刻向用户返回"抢购成功，订单处理中"的响应。
  3.  **异步消费**：后台有一个独立的消费者服务（`OrderConsumer`）监听消息队列。
  4.  **削峰填谷**：消费者按照自己的节奏，平稳地从队列中获取消息，并完成向数据库写入完整订单数据的操作，避免了对数据库的瞬时冲击。
- **核心组件**：
  - `RabbitTemplate`: 用于方便、快捷地向消息队列发送消息。
  - `@RabbitListener`: 注解在方法上，使其成为一个消息消费者，自动监听指定队列。

---

## 7. 配置与代码优化

- **连接池优化**：通过`application.yml`大幅增加并调优了数据库（Hikari）、Redis（Lettuce）的连接池大小，以及RabbitMQ的通道缓存大小，确保在高并发下有足够的连接资源。
- **Web服务器优化**：优化了内置Tomcat服务器的最大线程数和等待队列长度，使其能接待海量并发请求。
- **序列化优化**：配置了全局的`Jackson2JsonMessageConverter`，将对象到JSON的转换交由框架底层高效处理，显著降低了业务代码的CPU开销。
- **代码逻辑优化**：移除了分布式锁内冗余的Redis读操作，将两次网络请求合并为一次，最大限度地减少了锁的持有时间和CPU消耗。

---

## 8. Lua脚本的使用

- **库存扣减、库存回滚、锁释放、锁续期**等关键操作均通过Lua脚本实现，保证Redis操作的原子性和高性能。

---

## 总结

本系统通过Redis实现了高并发下的商品秒杀、库存管理、分布式锁、缓存、购物车等核心功能，极大提升了系统的并发处理能力和稳定性。每个功能都配有详细的注释和日志，便于理解和运维。

如需进一步了解某一功能的具体代码实现，可随时查阅对应的Service或工具类源码。
